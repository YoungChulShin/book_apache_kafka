# 5장. 카프카 컨슈머

컨슈머의 주요 기능
- 파티션 리더에게 메시지 가져오기 요청
- 각 요청은 로그의 오프셋을 명시하고 그 위치로부터 로그 메시지를 수신하기 때문에, 컨슈머는 가져올 메시지의 위치를 조정할 수 있고, 필요하면 가져온 데이터를 다시 가져올 수도 있다

## 5.1 컨슈머 주요 옵션
컨슈머의 종류
- 올드 컨슈머: 오프셋을 주키퍼의 지노드에 저장
- 뉴 컨슈머: 오프셋을 카픝카 토픽에 저장

주요 옵션
- bootstrap.servers
   - 카프카 클러스터에 연결하기 위한 호스트와 포트 정보
- fetch.min.bytes
   - 한번에 가져올 수 있는 최소 데이터 사이즈
- fetch.max.bytes
   - 한번에 가져올 수 있는 최대 데이터 사이즈
- fetch.max.wait.ms
   - fetch.min.bytes보다 작은 경우 요청에 응답을 기다리는 최대 시간
- group.id
   - 컨슈머가 속한 그룹을 식별하는 식별자
- enable.auto.commit
   - 백그라운드로 주기적으로 오프셋을 커밋
- auto.commit.intervals.ms
   - 주기적으로 오프셋을 커밋하는 시간
- auto.offset.reset
   - earliest: 가장 초기의 오프셋 값으로 설정
   - latest: 가장 마지막의 오프셋 값으로 설정
   - none: 이전 오프셋 값을 찾지 못하면 에러 발생
- request.timeout.ms
   - 요청에 대해 응답을 기다리는 최대 시간
- session.timeout.ms
   - 컨슈머와 브로커 사이의 세션 타입아웃 시간
   - 해당 시간이 지나면 컨슈머는 종요되거나 장애가 발생한 것으로 판단하고 컨슈머 그룹에서 리밸런스를 시도한다
- heartbeat.intervals.ms
   - 하트비트를 보내는 주기
   - session.timeout.ms보다 낮아야지 컨슈머가 살아있음을 알릴 수 있다
- max.poll.records
   - 단일 호출 poll()에 대한 최대 레코드 수
- max.poll.intervals.ms
   - 컨슈머가 하트비트만 보내고 메시지를 가져가지 ㅇ낳을 경우를 대비해서, 주기적으로 poll을 호출하지 않음을 체크하기 위한 시간

## 5.2 콘솔 컨슈머로 메시지 가져오기
카프카가 제공하는 컨슈며 명령어
- `/kafka/bin/kafka-console-consumer.sh`

컨슈머 그룹
- 컨슈머를 실행할 때에는 항상 컨슈머 그룹이 필요하며, `kafka-console-consumer.sh`를 실행할 때 옵션으로 들어간다
- 옵션을 설정하지 않으면 `console-consumer-xxxx`로 컨슈머 그룹이 자동생성된다
- `/kafka/bin/kafka-consumer-groups.sh` 에서 확인 가능하다

## 5.3 자바와 파이썬을 이용한 컨슈머
실습 코드로 대체함

## 5.4 파티션과 메시지 순서
정리
- 파티션이 n개일 때 파티션 내에서는 메시지의 순서가 보장되지만, 토픽을 기준으로는 메시지 순서가 보장되지 않는다
- 따라서 파티션이 n개일 때 토픽의 메시지를 보면 순서가 다르게 나타날 수 있다
- 이 부분에 대한 확인은 파티션별로 메시지를 보면 순서 보장을 확인 가능하다
   - `/kafka-console-consumer.sh --bootstrap-server {서버 정보} --topic peter-01 --partition 0 --from-beginning`
- 카프카를 사용하면서 메시지의 순서를 보장하기 위해서는 토픽의 파티션 수를 1로 설정하면 된다
   - 이 경우 순서 보장은 되지만 파티션이 1개이기 때문에 분산 처리를 할 수 없고, 처리량이 높지 않게 되는 단점이 있다

## 5.5 컨슈머 그룹
등장 배경
- 토픽의 파티션이 3개이고, 컨슈머가 1개라고 할 때 컨슈머가 1개라고 할 때 컨슈머가 토픽에서 보내는 메시지를 모두 처리하지 못할 수 있다. 
- 이 경우 컨슈머를 확장해야하는데, 단순하게 확장만 하면 오프셋 정보가 맞지 않아서 메시지가 꼬일 수 있다. 이를 위해서 카프카에서 컨슈머 그룹이라는 개념을 제공한다

컨슈머 그룹 특징 
- 카프카는 동일한 토픽에 대해서 여러 컨슈머가 메시지를 가져갈 수 있도록 컨슈며 그룹이라는 기능을 제공한다
- 컨슈머 그룹 안에서 컨슈머들은 메시지를 가져오고 있는 토픽에 대해 소유권을 공유한다
- 하나의 토픽에 여러 컨슈머 그룹이 동시에 접속해 메시지를 가져올 수 있다
   - 예를 들어서 A,B 2개의 팀이 있고 A팀에서 가지고 있는 로그 메시지를 B팀에서 필요하게 되었다고 하면,<br>
   A팀이 B팀으로 직접 데이터를 주는것이 아니라, 카프카 정보와 토픽 정보를 알려주면 B팀이 카프카 토픽에 접속해서 메시지를 가져올 수 있다
   - 이 방식이 가능한 이유는 컨슈머 그룹마다 별도의 오프셋을 관리하기 때문에 가능하다

리밸런스
- 컨슈머 그룹 내에서 컨슈머에 변경(추가/삭제)가 발생할 때 토픽 파티션의 소유권을 재 설정하는 과정
- 리밸런스를 하는 동안에는 일시적으로 메시지를 가져올 수 있는 단점이 있다

컨슈머가 토픽의 파티션보다 더 많을 경우는?
- 1개의 파티션에는 1개의 컨슈머만 연결할 수 있기 때문에 파티션이 설정되지 않은 컨슈머는 놀게 된다
- 이 경우는 파티션을 추가해서 수를 동일하게 유지해줘야 한다

## 5.6 커밋과 오프셋
개념
- 컨슈머 그룹의 컨슈머들은 각각의 파티션에 자신이 가져간 메시지의 위치 정보(오프셋)를 기록한다
- 각 파티션에 현재 위치를 업데이트 하는 동작을 커밋이라고 한다
- 카프카는 각 컨슈머 그룹의 파티션별로 오프셋 정보를 저장하기 위한 저장소가 별도로 필요하다

자동 커밋
- 옵션
   - enable.auto.commit=true
- 개념
   - 컨슈머가 poll()을 하면서 자동 커밋 시간이 되었을 경우에 커밋을 하는 방식
   - 방법은 편리하지만, 중복 등이 발생할 수 있기 때문에 동작 방식을 완벽하게 이해하고 사용하는 것이 중요하다
      - 자동으로 커밋을 하기 때문에 커밋 조건을 만족하지 않은 생타에서 리밸런스가 발생하면 동일 메시지를 다시 가져올 수 있다

수동 커밋
- 개념
   - 컨슈머가 메시지를 가져오자마자 커밋을 하는 것이 아니라, 처리할 동작(예: DB에 데이터 저장)을 하고 커밋을 할 수 있다
   - 커밋 시점을 자유롭게 조정할 수 있는 장점이 있다
   - 하지만 DB에 저장하는 과정에서 오류가 발생하면, 커밋 코드가 실행되지 않아서 동일한 메시지를 가져오고 DB에 데이터가 다시 들어갈 수 있다

특정 파티션 할당 및 특정 오프셋
- 코드 레벨에서 특정 파티션과 오프셋부터 메시지를 읽어올 지도 설정 가능하다

